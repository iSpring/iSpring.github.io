<!DOCTYPE html>
<html>

<head>
    <title>堆排序</title>
    <script>
        //------------------------------------堆排序（大顶堆，从大到小依次输出）--------------------------------------------
        /*
        http://www.cnblogs.com/dolphin0520/archive/2011/10/06/2199741.html
        http://www.cnblogs.com/jingmoxukong/p/4303826.html
        */
        //假设堆的为array[0]-array[lastIndex]
        //i是父节点，需要对i与2*i + 1 和2*i + 2进行判断
        //lastIndex是最后一个元素的索引值
        function adjustHeap(array, i, lastIndex){
            //首先要判断i是不是非叶子节点，如果i是叶子节点就不用处理
            if(i <= Math.floor(lastIndex / 2)){
                var leftChild = 2 * i + 1;
                var rightChild = leftChild + 1;
                var maxIndex = i;//maxIndex用于记录i、leftChild、rightChild中对应最大value值的索引
                if(leftChild <= lastIndex && array[leftChild] > array[maxIndex]){
                    //注意不要把array[leftChild] > array[maxIndex]写成array[leftChild] > array[i]
                    //判断左节点存是否存在，并进一步判断其值是否大于父节点
                    maxIndex = leftChild;
                }
                if(rightChild <= lastIndex && array[rightChild] > array[maxIndex]){
                    //注意不要把array[rightChild] > array[maxIndex]写成array[rightChild] > array[i]
                    //判断右节点存是否存在，并进一步判断其值是否大于父节点
                    maxIndex = rightChild;
                }
                //父节点的值比某一个子节点的值要小
                if(maxIndex !== i){
                    //父子节点交互
                    swap(array, i, maxIndex);
                    //交换之后，maxIndex对应的子节点的值变成了array[i]，变小了，
                    //这可能导致以maxIndex为父节点的子树不满足大顶堆，需要递归处理
                    adjustHeap(array, maxIndex, lastIndex);
                }
            }
        }

        //循环建立初始堆
        function buildHeap(array){
            //最后一个叶子节点
            var lastIndex = array.length - 1;
            //i开始指向最后一个非叶子节点
            var i = Math.floor(lastIndex / 2);
            //从最后一个非叶子节点向前一个叶子节点遍历，直至根节点            
            for(; i >= 0; i--){
                adjustHeap(array, i, lastIndex);
            }
        }

        function swap(array, i, j){
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }

        function heapSort(array){
            //首先循环建立初始堆
            buildHeap(array);

            //进行n-1次循环完成排序
            for(let i = array.length - 1; i > 0; i--){
                console.log(array[0]);//依次输出最大值、次最大值...
                //最后一个元素和第0个元素交互，此处的最后一个元素指的是array[i]
                swap(array, 0, i);
                //重新调整成大顶堆
                adjustHeap(array, 0, i - 1);//注意最后一个参数是i - 1，而不是i
            }

            //上面for循环中console.log()依次从最大值开始输出，但是此处最终的array是从小到大排列的
            console.log(array);
        }

        heapSort([1, 3, 4, 5, 2, 6, 9, 7, 8, 0]);
    </script>
</head>

<body>

</body>

</html>